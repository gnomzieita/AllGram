//  Converted to Swift 5.4 by Swiftify v5.4.22271 - https://swiftify.com/
/*
 Copyright 2015 OpenMarket Ltd
 Copyright 2018 New Vector Ltd

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

import Foundation
import MatrixSDK
import MobileCoreServices

/// List attachment types
enum AttachmentType : Int {
    case undefined
    case image
    case audio
    case voiceMessage
    case video
    case location
    case file
    case sticker
}

// The size of thumbnail we request from the server
// Note that this is smaller than the ones we upload: when sending, one size
// must fit all, including the web which will want relatively high res thumbnails.
// We, however, are a mobile client and so would prefer smaller thumbnails, which
// we can have if they're being generated by the media repo.
private let kThumbnailWidth = 320
private let kThumbnailHeight = 240
let kMXKAttachmentErrorDomain = "kMXKAttachmentErrorDomain"

/// `Attachment` represents a room attachment.
class Attachment {
    /// The information on the encrypted content.
    private var contentFile: MXEncryptedContentFile?
    /// The information on the encrypted thumbnail.
    private var thumbnailFile: MXEncryptedContentFile?
    /// Observe Attachment download
    private var onAttachmentDownloadObs: Any?
    /// The local path used to store the attachment with its original name
    private var documentCopyPath: String?
    /// The attachment mimetype.
    private var mimetype: String?

    /// The media manager instance used to download the attachment data.
    private(set) var mediaManager: MXMediaManager?
    /// The attachment type.
    private(set) var type: AttachmentType!
    /// The attachment information retrieved from the event content during the initialisation.
    private(set) var eventId: String?
    private(set) var eventRoomId: String?
    private(set) var eventSentState: MXEventSentState?
    private(set) var contentURL: String?
    private(set) var contentInfo: [AnyHashable : Any]?
    /// The URL of a 'standard size' thumbnail.
    private(set) var mxcThumbnailURI: String?
    private(set) var thumbnailMimeType: String?
    /// The download identifier of the attachment content (related to contentURL).
    private(set) var downloadId: String?
    /// The download identifier of the attachment thumbnail.
    private(set) var thumbnailDownloadId: String?
    /// The attached video thumbnail information.
    private(set) var thumbnailInfo: [AnyHashable : Any]?
    /// The original file name retrieved from the event body (if any).
    private(set) var originalFileName: String?
    /// The thumbnail orientation (relevant in case of image).
    private(set) var thumbnailOrientation: (UIImage.Orientation)!
    /// The cache file path of the attachment.
    private(set) var cacheFilePath: String?
    /// The cache file path of the attachment thumbnail (may be nil).
    private(set) var thumbnailCachePath: String?
    /// The preview of the attachment (nil by default).
    var previewImage: UIImage?
    /// True if the attachment is encrypted
    /// The encryption status of the thumbnail is not covered by this
    /// property: it is possible for the thumbnail to be encrypted
    /// whether this peoperty is true or false.
    private(set) var isEncrypted = false

    /// Create a `Attachment` instance for the passed event.
    /// The created instance copies the current data of the event (content, event id, sent state...).
    /// It will ignore any future changes of these data.
    /// - Parameters:
    ///   - event: a matrix event.
    ///   - mediaManager: the media manager instance used to download the attachment data.
    /// - Returns: `Attachment` instance.
    init?(event: MXEvent, andMediaManager mediaManager: MXMediaManager) {
        self.mediaManager = mediaManager

        // Make a copy as the data can be read at anytime later
        eventId = event.eventId
        eventRoomId = event.roomId
        eventSentState = event.sentState

        let eventContent = event.content

        // Set default thumbnail orientation
        thumbnailOrientation = UIImage.Orientation.up

        if event.eventType == .sticker {
            type = .sticker
            thumbnailInfo = eventContent!
        } else {
            // Note: mxEvent.eventType is supposed to be MXEventTypeRoomMessage here.
            let msgtype = eventContent!["msgtype"] as? String
            if msgtype == kMXMessageTypeImage {
                type = .image
            } else if event.isVoiceMessage() {
                type = .voiceMessage
            } else if msgtype == kMXMessageTypeAudio {
                type = .audio
            } else if msgtype == kMXMessageTypeVideo {
                type = .video
                thumbnailInfo = eventContent
            } else if msgtype == kMXMessageTypeLocation {
                // Not supported yet
                // _type = MXKAttachmentTypeLocation;
                return nil
            } else if msgtype == kMXMessageTypeFile {
                type = .file
            } else {
                return nil
            }
        }

        originalFileName = eventContent!["body"] as? String
        contentInfo = eventContent!["info"] as? [String : Any]
        if let _ = eventContent!["file"] as? [String : Any] {
            contentFile = MXEncryptedContentFile(fromJSON: eventContent!["file"] as? [String : Any])
        }
        
        // Retrieve the content url by taking into account the potential encryption.
        if let contentFile = contentFile {
            isEncrypted = true
            contentURL = contentFile.url
            thumbnailFile = MXEncryptedContentFile(fromJSON: contentInfo?["thumbnail_file"] as? [AnyHashable : Any])
        } else {
            isEncrypted = false
            contentURL = eventContent?["url"] as? String
        }

        mimetype = nil
        if contentInfo != nil {
            mimetype = contentInfo?["mimetype"] as? String
        }

        cacheFilePath = MXMediaManager.cachePath(forMatrixContentURI: contentURL, andType: mimetype, inFolder: eventRoomId)
        downloadId = MXMediaManager.downloadId(forMatrixContentURI: contentURL, inFolder: eventRoomId)

        // Deduce the thumbnail information from the retrieved data.
        if type == .image {
            mxcThumbnailURI = getThumbnailURI()
            thumbnailMimeType = getThumbnailMimeType()
            thumbnailCachePath = getThumbnailCachePath()
            thumbnailDownloadId = getThumbnailDownloadId()
        }
    }

    deinit {
        destroy()
    }

    func destroy() {
        if onAttachmentDownloadObs != nil {
            if let onAttachmentDownloadObs = onAttachmentDownloadObs {
                NotificationCenter.default.removeObserver(onAttachmentDownloadObs)
            }
            onAttachmentDownloadObs = nil
        }

        // Remove the temporary file created to prepare attachment sharing
        if documentCopyPath != nil {
            do {
                try FileManager.default.removeItem(atPath: documentCopyPath ?? "")
            } catch {
            }
            documentCopyPath = nil
        }

        previewImage = nil
    }

    func getThumbnailURI() -> String {
        if let thumbnailFile = thumbnailFile {
            // there's an encrypted thumbnail: we return the mxc url
            return thumbnailFile.url ?? ""
        }

        // Look for a clear thumbnail url
        return contentInfo?["thumbnail_url"] as? String ?? ""
    }

    func getThumbnailMimeType() -> String {
        return thumbnailInfo?["mimetype"] as? String ?? ""
    }

    func getThumbnailCachePath() -> String {
        if mxcThumbnailURI != nil {
            return MXMediaManager.cachePath(forMatrixContentURI: mxcThumbnailURI, andType: thumbnailMimeType, inFolder: eventRoomId)
        } else if type == .image && !isEncrypted && contentURL != nil && !(contentURL?.hasPrefix(kMXMediaUploadIdPrefix) ?? false) {
            return MXMediaManager.thumbnailCachePath(
                forMatrixContentURI: contentURL,
                andType: "image/jpeg",
                inFolder: eventRoomId,
                toFitViewSize: CGSize(width: CGFloat(kThumbnailWidth), height: CGFloat(kThumbnailHeight)),
                with: MXThumbnailingMethodScale)
        }
        return ""
    }

    func getThumbnailDownloadId() -> String {
        if mxcThumbnailURI != nil {
            return MXMediaManager.downloadId(forMatrixContentURI: mxcThumbnailURI, inFolder: eventRoomId)
        } else if type == .image && !isEncrypted && contentURL != nil && !(contentURL?.hasPrefix(kMXMediaUploadIdPrefix) ?? false) {
            return MXMediaManager.thumbnailDownloadId(
                forMatrixContentURI: contentURL,
                inFolder: eventRoomId,
                toFitViewSize: CGSize(width: CGFloat(kThumbnailWidth), height: CGFloat(kThumbnailHeight)),
                with: MXThumbnailingMethodScale)
        }
        return ""
    }

    /// Gets the thumbnail for this attachment if it is in the memory or disk cache,
    /// otherwise return nil
    func getCachedThumbnail() -> UIImage? {
        if thumbnailCachePath != nil {
            let thumb = MXMediaManager.getFromMemoryCache(withFilePath: thumbnailCachePath)
            if let thumb = thumb {
                return thumb
            }

            if FileManager.default.fileExists(atPath: thumbnailCachePath ?? "") {
                return MXMediaManager.loadThroughCache(withFilePath: thumbnailCachePath)
            }
        }
        return nil
    }

    /// Gets the thumbnails for this attachment, downloading it or loading it from disk cache
    /// if necessary
    func getThumbnail(_ onSuccess: @escaping (Attachment, UIImage) -> Void, failure onFailure: @escaping (Attachment, _ error: Error?) -> Void) {
        // Check whether a thumbnail is defined.
        if thumbnailCachePath == nil {
            // there is no thumbnail: if we're an image, return the full size image. Otherwise, nothing we can do.
            if type == .image {
                getImage(onSuccess, failure: onFailure)
            } else {
                onFailure(self, nil)
            }

            return
        }

        // Check the current memory cache.
        let thumb = MXMediaManager.getFromMemoryCache(withFilePath: thumbnailCachePath)
        if let thumb = thumb {
            onSuccess(self, thumb)
            return
        }

        if let thumbnailFile = thumbnailFile {

            let decryptAndCache: (() -> Void)? = { [self] in
                let instream = InputStream(fileAtPath: thumbnailCachePath ?? "")
                let outstream = OutputStream()
                MXEncryptedAttachments.decryptAttachment(thumbnailFile, inputStream: instream, outputStream: outstream, success: { [self] in
                    var img: UIImage? = nil
                    if let property = outstream.property(forKey: .dataWrittenToMemoryStreamKey) as? Data {
                        img = UIImage(data: property)
                    }
                    // Save this image to in-memory cache.
                    MXMediaManager.cacheImage(img, withCachePath: thumbnailCachePath)
                    onSuccess(self, img!)
                }, failure: { err in
                    if err != nil {
                        onFailure(self, err)
                        return
                    }
                })
            }

            if FileManager.default.fileExists(atPath: thumbnailCachePath ?? "") {
                decryptAndCache?()
            } else {
                mediaManager?.downloadEncryptedMedia(
                    fromMatrixContentFile: thumbnailFile,
                    mimeType: thumbnailMimeType,
                    inFolder: eventRoomId,
                    success: { outputFilePath in
                        decryptAndCache?()
                    },
                    failure: { error in
                        onFailure(self, error)
                    })
            }
        } else {
            if FileManager.default.fileExists(atPath: thumbnailCachePath ?? "") {
                onSuccess(self, MXMediaManager.loadThroughCache(withFilePath: thumbnailCachePath))
            } else if mxcThumbnailURI != nil {
                mediaManager?.downloadMedia(
                    fromMatrixContentURI: mxcThumbnailURI,
                    withType: thumbnailMimeType,
                    inFolder: eventRoomId,
                    success: { outputFilePath in
                        // Here outputFilePath = thumbnailCachePath
                        onSuccess(self, MXMediaManager.loadThroughCache(withFilePath: outputFilePath))
                    },
                    failure: { error in
                        onFailure(self, error)
                    })
            } else {
                // Here _thumbnailCachePath is defined, so a thumbnail is available.
                // Because _mxcThumbnailURI is null, this means we have to consider the content uri (see getThumbnailCachePath).
                mediaManager?.downloadThumbnail(
                    fromMatrixContentURI: contentURL,
                    withType: "image/jpeg",
                    inFolder: eventRoomId,
                    toFitViewSize: CGSize(width: CGFloat(kThumbnailWidth), height: CGFloat(kThumbnailHeight)),
                    with: MXThumbnailingMethodScale,
                    success: { outputFilePath in
                        // Here outputFilePath = thumbnailCachePath
                        onSuccess(self, MXMediaManager.loadThroughCache(withFilePath: outputFilePath))
                    },
                    failure: { error in
                        onFailure(self, error)
                    })
            }
        }
    }

    /// For image attachments, gets a UIImage for the full-res image
    func getImage(_ onSuccess: @escaping (Attachment, UIImage) -> Void, failure onFailure: @escaping (Attachment, _ error: Error?) -> Void) {
        getData({ data in

            let img = UIImage(data: data)

            if let img = img {
                onSuccess(self, img)
            } else {
                let error = NSError(domain: kMXKAttachmentErrorDomain, code: 0, userInfo: [
                    "err": "error_get_image_from_data"
                ])
                onFailure(self, error)
            }

        }, failure: { error in
            onFailure(self, error)
        })
    }

    /// Decrypt the attachment data into memory and provide it as an NSData
    func getData(_ onSuccess: @escaping (Data) -> Void, failure onFailure: @escaping (_ error: Error?) -> Void) {
        prepare({ [self] in
            if isEncrypted {
                // decrypt the encrypted file
                let instream = InputStream(fileAtPath: cacheFilePath ?? "")
                let outstream = OutputStream()
                MXEncryptedAttachments.decryptAttachment(contentFile, inputStream: instream, outputStream: outstream, success: {
                    onSuccess(outstream.property(forKey: .dataWrittenToMemoryStreamKey) as! (Data))
                }, failure: { err in
                    if err != nil {
                        return
                    }
                })
            } else {
                onSuccess(try! Data(contentsOf: URL(string: cacheFilePath!)!))
            }
        }, failure: onFailure)
    }

    /// Decrypts the attachment to a newly created temporary file.
    /// If the isEncrypted property is YES, this method (or getImage) should be used to
    /// obtain the full decrypted attachment. The behaviour of this method is undefined
    /// if isEncrypted is NO.
    /// It is the caller's responsibility to delete the temporary file once it is no longer
    /// needed.
    func decrypt(toTempFile onSuccess: @escaping (String) -> Void, failure onFailure: @escaping (_ error: Error?) -> Void) {
        prepare({ [self] in
            let tempPath = getTempFile()
            if tempPath == "" {
                onFailure(NSError(domain: kMXKAttachmentErrorDomain, code: 0, userInfo: [
                    "err": "error_creating_temp_file"
                ]))
                return
            }

            let inStream = InputStream(fileAtPath: cacheFilePath ?? "")
            let outStream = OutputStream.init(toFileAtPath: tempPath, append: false)

            MXEncryptedAttachments.decryptAttachment(contentFile, inputStream: inStream, outputStream: outStream, success: {
                onSuccess(tempPath)
            }, failure: { err in
                if err != nil {
                    onFailure(err!)
                    return
                }
            })
        }, failure: onFailure)
    }

    func getTempFile() -> String {
        // create a file with an appropriate extension because iOS detects based on file extension
        // all over the place
        let ext = MXTools.fileExtension(fromContentType: mimetype)
        let filenameTemplate = "attatchment.XXXXXX\(ext!)"
        let template = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(filenameTemplate)

        return template.withUnsafeFileSystemRepresentation { templateCstr -> String in
            
            guard let templateCstr = templateCstr else { return "" }
            let buffer = UnsafeMutablePointer<CChar>.allocate(capacity: strlen(templateCstr) + 1)
            
            let fd = mkstemps(buffer, Int32(ext!.count))
            if fd == 0 {
                return ""
            }
            close(fd)

            let tempPath = FileManager.default.string(
                withFileSystemRepresentation: buffer,
                length: strlen(buffer))
            buffer.deallocate()
            
            return tempPath
        }
    }

    func prepare(_ onAttachmentReady: @escaping () -> Void, failure onFailure: @escaping (_ error: Error?) -> Void) {
        if FileManager.default.fileExists(atPath: cacheFilePath ?? "") {
        // Done
            onAttachmentReady()
        } else {
            // Trigger download if it is not already in progress
            var loader = MXMediaManager.existingDownloader(withIdentifier: downloadId)
            if loader == nil {
                if isEncrypted {
                    loader = mediaManager?.downloadEncryptedMedia(
                        fromMatrixContentFile: contentFile,
                        mimeType: mimetype,
                        inFolder: eventRoomId)
                } else {
                    loader = mediaManager?.downloadMedia(
                        fromMatrixContentURI: contentURL,
                        withType: mimetype,
                        inFolder: eventRoomId)
                }
            }

            if let loader = loader {
                // Add observers
                onAttachmentDownloadObs = NotificationCenter.default.addObserver(forName: NSNotification.Name.mxMediaLoaderStateDidChange, object: loader, queue: OperationQueue.main, using: { [self] notif in

                    let loader = notif.object as? MXMediaLoader
                    switch loader?.state {
                    case MXMediaLoaderStateDownloadCompleted:
                        if let onAttachmentDownloadObs = onAttachmentDownloadObs {
                            NotificationCenter.default.removeObserver(onAttachmentDownloadObs)
                        }
                        onAttachmentDownloadObs = nil
                        onAttachmentReady()
                    case MXMediaLoaderStateDownloadFailed, MXMediaLoaderStateCancelled:
                        if let onAttachmentDownloadObs = onAttachmentDownloadObs {
                            NotificationCenter.default.removeObserver(onAttachmentDownloadObs)
                        }
                        onAttachmentDownloadObs = nil
                        onFailure((loader?.error)!)
                    default:
                        break
                    }
                })
            } else {
                onFailure(nil)
            }
        }
    }

    /// Save the attachment in user's photo library. This operation is available only for images and video.
    /// - Parameters:
    ///   - onSuccess: the block called on success.
    ///   - onFailure: the block called on failure.
    func save(_ onSuccess: @escaping () -> Void, failure onFailure: @escaping (_ error: Error?) -> Void) {
        if type == .image || type == .video {
            if isEncrypted {
                decrypt(toTempFile: { [self] path in
                    let url = URL(fileURLWithPath: path)

                    MXMediaManager.saveMedia(
                        toPhotosLibrary: url,
                        isImage: (type == .image),
                        success: { assetURL in
                            do {
                                try FileManager.default.removeItem(atPath: path)
                            } catch {
                            }
                            onSuccess()
                        },
                        failure: onFailure)
                }, failure: onFailure)
            } else {
                prepare({ [self] in
                    let url = URL(fileURLWithPath: cacheFilePath ?? "")

                    MXMediaManager.saveMedia(
                        toPhotosLibrary: url,
                        isImage: (type == .image),
                        success: { assetURL in
                            onSuccess()
                        },
                        failure: onFailure)
                }, failure: onFailure)
            }
        } else {
        // Not supported
            onFailure(nil)
        }
    }

    /// Copy the attachment data in general pasteboard.
    /// - Parameters:
    ///   - onSuccess: the block called on success.
    ///   - onFailure: the block called on failure.
    func copy(_ onSuccess: @escaping () -> Void, failure onFailure: @escaping (_ error: Error?) -> Void) {
        prepare({ [self] in
            if type == .image {
                getImage({ attachment, img in
                    PasteboardManager.shared.pasteboard.image = img
                    onSuccess()
                }, failure: { attachment, error in
                    onFailure(error)
                })
            } else {
                getData({ [self] data in
                    let UTI = UTType(tag: URL(fileURLWithPath: cacheFilePath!).pathExtension, tagClass: .filenameExtension, conformingTo: nil)
                        //UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, URL(fileURLWithPath: cacheFilePath!).pathExtension as CFString, nil) as? String

                    if let UTI = UTI {
                        PasteboardManager.shared.pasteboard.setData(data, forPasteboardType: UTI.identifier)
                        onSuccess()
                    }
                }, failure: onFailure)
            }

        // Unexpected error
            onFailure(nil)

        }, failure: onFailure)
    }

    /// Prepare the attachment data to share it. The original name of the attachment (if any) is used
    /// to name the prepared file.
    /// The developer must call 'onShareEnd' when share operation is ended in order to release potential
    /// resources allocated here.
    /// - Parameters:
    ///   - onReadyToShare: the block called when attachment is ready to share at the provided file URL.
    ///   - onFailure: the block called on failure.
    func prepareShare(_ onReadyToShare: @escaping (_ fileURL: URL) -> Void, failure onFailure: @escaping (_ error: Error?) -> Void) {
        let haveFile: ((String) -> Void)? = { [self] path in
            // Prepare the file URL by considering the original file name (if any)
            var fileUrl: URL?
            // Check whether the original name retrieved from event body has extension
            if originalFileName != nil && (URL(fileURLWithPath: originalFileName ?? "").pathExtension.count) != 0 {
                // Copy the cached file to restore its original name
                // Note:  We used previously symbolic link (instead of copy) but UIDocumentInteractionController failed to open Office documents (.docx, .pptx...).
                documentCopyPath = URL(fileURLWithPath: MXMediaManager.getCachePath()).appendingPathComponent(originalFileName ?? "").path

                do {
                    try FileManager.default.removeItem(atPath: documentCopyPath ?? "")
                } catch {
                }
                do {
                    try FileManager.default.copyItem(atPath: path, toPath: documentCopyPath ?? "")

                    fileUrl = URL(fileURLWithPath: documentCopyPath ?? "")
                } catch {
                }
            }

            if fileUrl == nil {
                // Use the cached file by default
                fileUrl = URL(fileURLWithPath: path)
            }

            onReadyToShare(fileUrl!)
        }

        if isEncrypted {
            decrypt(toTempFile: { path in
                haveFile?(path)
                do {
                    try FileManager.default.removeItem(atPath: path)
                } catch {
                }
            }, failure: onFailure)
        } else {
            // First download data if it is not already done
            prepare({ [self] in
                haveFile?(cacheFilePath ?? "")
            }, failure: onFailure)
        }
    }

    func onShareEnded() {
        // Remove the temporary file created to prepare attachment sharing
        if documentCopyPath != nil {
            do {
                try FileManager.default.removeItem(atPath: documentCopyPath ?? "")
            } catch {
            }
            documentCopyPath = nil
        }
    }
}
